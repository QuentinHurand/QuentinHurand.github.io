<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Color Connect - Arcade Neon</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

  body {
    margin: 0; padding: 0;
    background-color: #111;
    color: #0ff;
    font-family: 'Press Start 2P', cursive, monospace;
    display: flex; flex-direction: column; align-items: center;
    min-height: 100vh;
  }
  h1 {
    margin: 20px 0 10px 0;
    color: #0ff;
    text-shadow: 0 0 8px #0ff;
  }
  #mode-select, #game-container {
    width: 100%;
    max-width: 600px;
    text-align: center;
  }
  button {
    font-family: 'Press Start 2P', monospace;
    background: transparent;
    border: 3px solid #0ff;
    color: #0ff;
    padding: 12px 20px;
    margin: 10px;
    cursor: pointer;
    text-transform: uppercase;
    font-size: 14px;
    border-radius: 10px;
    transition: 0.3s;
  }
  button:hover {
    background-color: #0ff;
    color: #111;
    text-shadow: none;
  }

  #board {
    margin: 20px auto;
    display: grid;
    grid-gap: 4px;
    background: #222;
    border-radius: 15px;
    padding: 10px;
    box-shadow: 0 0 15px #0ff;
    user-select: none;
  }

  .cell {
    width: 40px; height: 40px;
    border-radius: 8px;
    background-color: #222;
    box-shadow: inset 0 0 5px #000;
    cursor: pointer;
    position: relative;
  }
  .cell.start-point {
    box-shadow: 0 0 12px 3px;
    cursor: pointer;
  }
  .cell.path {
    background-color: transparent;
  }
  .color-dot {
    width: 24px; height: 24px;
    border-radius: 50%;
    position: absolute;
    top: 8px; left: 8px;
    box-shadow: 0 0 10px;
  }
  /* neon colors for dots */
  .color-0 { background: #ff0055; box-shadow: 0 0 8px #ff0055; }
  .color-1 { background: #00ffff; box-shadow: 0 0 8px #00ffff; }
  .color-2 { background: #ffaa00; box-shadow: 0 0 8px #ffaa00; }
  .color-3 { background: #00ff44; box-shadow: 0 0 8px #00ff44; }
  .color-4 { background: #aa00ff; box-shadow: 0 0 8px #aa00ff; }
  .color-5 { background: #ff00ff; box-shadow: 0 0 8px #ff00ff; }
  .color-6 { background: #44ffff; box-shadow: 0 0 8px #44ffff; }
  .color-7 { background: #ff8844; box-shadow: 0 0 8px #ff8844; }
  .color-8 { background: #88ff44; box-shadow: 0 0 8px #88ff44; }

  /* path style */
  .path-color-0 { background-color: #ff0055; box-shadow: 0 0 8px #ff0055; }
  .path-color-1 { background-color: #00ffff; box-shadow: 0 0 8px #00ffff; }
  .path-color-2 { background-color: #ffaa00; box-shadow: 0 0 8px #ffaa00; }
  .path-color-3 { background-color: #00ff44; box-shadow: 0 0 8px #00ff44; }
  .path-color-4 { background-color: #aa00ff; box-shadow: 0 0 8px #aa00ff; }
  .path-color-5 { background-color: #ff00ff; box-shadow: 0 0 8px #ff00ff; }
  .path-color-6 { background-color: #44ffff; box-shadow: 0 0 8px #44ffff; }
  .path-color-7 { background-color: #ff8844; box-shadow: 0 0 8px #ff8844; }
  .path-color-8 { background-color: #88ff44; box-shadow: 0 0 8px #88ff44; }

  #info {
    margin-top: 10px;
    font-size: 16px;
    color: #0ff;
    text-shadow: 0 0 6px #0ff;
  }
  #level-indicator {
    font-size: 18px;
    margin-top: 10px;
    font-weight: bold;
    text-shadow: 0 0 8px #0ff;
  }
  #message {
    margin-top: 15px;
    font-size: 18px;
    color: #ff0066;
    text-shadow: 0 0 8px #ff0066;
  }
</style>
</head>
<body>

<h1>Color Connect - Arcade Neon</h1>

<div id="mode-select">
  <button id="btn-campaign">Mode Campagne</button>
  <button id="btn-practice">Mode Practice</button>
</div>

<div id="game-container" style="display:none;">
  <div id="level-indicator"></div>
  <div id="board"></div>
  <div id="info">Clique et glisse pour connecter les paires !</div>
  <div id="message"></div>
  <button id="btn-restart">Recommencer Niveau</button>
  <button id="btn-back">Retour au choix du mode</button>
</div>

<script>
(() => {
  const boardElem = document.getElementById("board");
  const modeSelect = document.getElementById("mode-select");
  const gameContainer = document.getElementById("game-container");
  const levelIndicator = document.getElementById("level-indicator");
  const info = document.getElementById("info");
  const message = document.getElementById("message");
  const btnRestart = document.getElementById("btn-restart");
  const btnBack = document.getElementById("btn-back");

  // Palette néon - 9 couleurs max
  const COLORS = [
    "#ff0055", "#00ffff", "#ffaa00", "#00ff44", "#aa00ff", "#ff00ff", "#44ffff", "#ff8844", "#88ff44"
  ];

  // Variables jeu
  let gridSize;
  let pairsCount;
  let level = 1;
  let maxLevel = 30;
  let mode = null; // "campaign" or "practice"

  let grid = []; // matrice de cases : chaque case = {color: number|null, type: "empty"|"start", pathColor: number|null}
  let pairs = []; // array of {color: number, positions: [{x,y}, {x,y}]}
  let paths = {}; // color -> array of positions currently drawn
  let drawingColor = null;
  let drawingPath = [];
  let isDrawing = false;

  // Utils
  function posToIndex(x, y) {
    return y * gridSize + x;
  }
  function indexToPos(i) {
    return {x: i % gridSize, y: Math.floor(i / gridSize)};
  }
  function samePos(a, b) {
    return a.x === b.x && a.y === b.y;
  }
  function adjacent(a, b) {
    // cases adjacentes (4 directions)
    return (Math.abs(a.x - b.x) + Math.abs(a.y - b.y)) === 1;
  }
  // shuffle array
  function shuffle(arr) {
    for (let i=arr.length-1; i>0; i--) {
      const j = Math.floor(Math.random()*(i+1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }
  // deep clone 2d array
  function cloneGrid(grid) {
    return grid.map(row => row.map(cell => ({...cell, pathColor: cell.pathColor})));
  }

  // Génére la grille et paires pour un niveau donné (campagne)
  // Niveau facile -> 5x5 avec 3 paires, augmente jusqu'à 9x9 avec 8 paires
  function generateCampaignLevel(level) {
    // calcul taille grille et nb paires
    const minSize = 5;
    const maxSize = 9;
    gridSize = Math.min(maxSize, minSize + Math.floor(level / 4)); // augmente tous les 4 niveaux
    pairsCount = Math.min(3 + Math.floor(level / 3), 8);

    // crée la grille vide
    grid = [];
    for(let y=0; y<gridSize; y++) {
      const row = [];
      for(let x=0; x<gridSize; x++) {
        row.push({color: null, type:"empty", pathColor: null});
      }
      grid.push(row);
    }

    // choix aléatoire des couleurs utilisées pour les paires
    const colorIndices = shuffle([...Array(COLORS.length).keys()]).slice(0, pairsCount);

    // place aléatoirement 2 points pour chaque paire, en évitant chevauchements
    pairs = [];
    for(let i=0; i<pairsCount; i++) {
      let pos1, pos2;
      do {
        pos1 = {x: Math.floor(Math.random()*gridSize), y: Math.floor(Math.random()*gridSize)};
      } while(grid[pos1.y][pos1.x].color !== null);
      grid[pos1.y][pos1.x] = {color: colorIndices[i], type:"start", pathColor: colorIndices[i]};
      do {
        pos2 = {x: Math.floor(Math.random()*gridSize), y: Math.floor(Math.random()*gridSize)};
      } while((grid[pos2.y][pos2.x].color !== null) || (pos1.x === pos2.x && pos1.y === pos2.y));
      grid[pos2.y][pos2.x] = {color: colorIndices[i], type:"start", pathColor: colorIndices[i]};
      pairs.push({color: colorIndices[i], positions:[pos1, pos2]});
    }

    paths = {};
    drawingColor = null;
    drawingPath = [];
  }

  // Génération aléatoire pour practice : grille carré 5-8, 3-7 paires
  function generatePracticeLevel() {
    gridSize = 5 + Math.floor(Math.random()*4); // 5-8
    pairsCount = 3 + Math.floor(Math.random()*5); // 3-7

    // grille vide
    grid = [];
    for(let y=0; y<gridSize; y++) {
      const row = [];
      for(let x=0; x<gridSize; x++) {
        row.push({color: null, type:"empty", pathColor: null});
      }
      grid.push(row);
    }
    // couleurs choisies
    const colorIndices = shuffle([...Array(COLORS.length).keys()]).slice(0, pairsCount);

    pairs = [];
    for(let i=0; i<pairsCount; i++) {
      let pos1, pos2;
      do {
        pos1 = {x: Math.floor(Math.random()*gridSize), y: Math.floor(Math.random()*gridSize)};
      } while(grid[pos1.y][pos1.x].color !== null);
      grid[pos1.y][pos1.x] = {color: colorIndices[i], type:"start", pathColor: colorIndices[i]};
      do {
        pos2 = {x: Math.floor(Math.random()*gridSize), y: Math.floor(Math.random()*gridSize)};
      } while((grid[pos2.y][pos2.x].color !== null) || (pos1.x === pos2.x && pos1.y === pos2.y));
      grid[pos2.y][pos2.x] = {color: colorIndices[i], type:"start", pathColor: colorIndices[i]};
      pairs.push({color: colorIndices[i], positions:[pos1, pos2]});
    }

    paths = {};
    drawingColor = null;
    drawingPath = [];
  }

  // Affiche la grille à l'écran
  function renderBoard() {
    boardElem.innerHTML = "";
    boardElem.style.gridTemplateColumns = `repeat(${gridSize}, 40px)`;
    boardElem.style.gridTemplateRows = `repeat(${gridSize}, 40px)`;

    for(let y=0; y<gridSize; y++) {
      for(let x=0; x<gridSize; x++) {
        const cell = document.createElement("div");
        cell.className = "cell";
        cell.dataset.x = x;
        cell.dataset.y = y;

        const cellData = grid[y][x];

        if(cellData.type === "start") {
          cell.classList.add("start-point");
          const dot = document.createElement("div");
          dot.className = `color-dot color-${cellData.color}`;
          cell.appendChild(dot);
        }
        else if(cellData.pathColor !== null) {
          cell.classList.add(`path-color-${cellData.pathColor}`);
          cell.style.backgroundColor = COLORS[cellData.pathColor];
          cell.style.opacity = "0.6";
        }

        boardElem.appendChild(cell);
      }
    }
  }

  // Efface un chemin existant d'une couleur (dans grid et paths)
  function clearPath(color) {
    if(!paths[color]) return;
    for(const p of paths[color]) {
      if(grid[p.y][p.x].type !== "start") {
        grid[p.y][p.x].pathColor = null;
      }
    }
    delete paths[color];
  }

  // Vérifie si toutes cases sont remplies (path ou start)
  function isBoardComplete() {
    for(let y=0; y<gridSize; y++) {
      for(let x=0; x<gridSize; x++) {
        if(grid[y][x].pathColor === null && grid[y][x].type !== "start") return false;
      }
    }
    return true;
  }

  // Vérifie si un chemin est valide: relie les 2 points start et chaque cellule adjacente
  // Pour simplifier, on valide dès que les 2 starts sont reliés avec un chemin continu.
  function isPathValid(color, path) {
    if(path.length < 2) return false;

    // vérifie que chemin commence et finit sur les 2 starts
    const startPositions = pairs.find(p => p.color === color).positions;
    if(!samePos(path[0], startPositions[0]) && !samePos(path[0], startPositions[1])) return false;
    if(!samePos(path[path.length-1], startPositions[0]) && !samePos(path[path.length-1], startPositions[1])) return false;

    // vérifie que chaque case est adjacente à la suivante
    for(let i=1; i<path.length; i++) {
      if(!adjacent(path[i-1], path[i])) return false;
    }

    // vérifie que le chemin ne passe pas par un autre start de couleur différente (sauf aux extrémités)
    for(let i=1; i<path.length-1; i++) {
      const c = grid[path[i].y][path[i].x].color;
      if(c !== null && c !== color) return false;
    }

    return true;
  }

  // Dessine un chemin dans la grille
  function drawPath(color, path) {
    clearPath(color);
    paths[color] = path;
    for(const p of path) {
      if(grid[p.y][p.x].type !== "start") {
        grid[p.y][p.x].pathColor = color;
      }
    }
  }

  // Handle souris/tactile pour tracer chemin
  function handlePointerDown(e) {
    if(e.target.classList.contains("start-point")) {
      const x = +e.target.dataset.x;
      const y = +e.target.dataset.y;
      drawingColor = grid[y][x].color;
      drawingPath = [{x,y}];
      isDrawing = true;
      clearPath(drawingColor);
      renderBoard();
      drawPath(drawingColor, drawingPath);
      renderBoard();
      e.preventDefault();
    }
  }

  function handlePointerMove(e) {
    if(!isDrawing) return;
    const rect = boardElem.getBoundingClientRect();
    let clientX, clientY;
    if(e.touches) {
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    } else {
      clientX = e.clientX;
      clientY = e.clientY;
    }
    const x = Math.floor((clientX - rect.left) / 44);
    const y = Math.floor((clientY - rect.top) / 44);
    if(x < 0 || y < 0 || x >= gridSize || y >= gridSize) return;

    const last = drawingPath[drawingPath.length - 1];
    if(last.x === x && last.y === y) return; // pas de déplacement

    // autorise seulement les déplacements sur case adjacente
    if(!adjacent(last, {x,y})) return;

    // pas repasser sur un chemin d'une autre couleur sauf si c'est la fin (retour arrière)
    const cell = grid[y][x];
    if(cell.pathColor !== null && cell.pathColor !== drawingColor) return;

    // pas repasser 2 fois sur la même case
    if(drawingPath.some(p => samePos(p, {x,y}))) {
      // autorise seulement retour arrière d'une case
      if(drawingPath.length > 1 && samePos(drawingPath[drawingPath.length - 2], {x,y})) {
        // retour arrière, on supprime dernière case
        drawingPath.pop();
      } else {
        return;
      }
    } else {
      drawingPath.push({x,y});
    }

    drawPath(drawingColor, drawingPath);
    renderBoard();
  }

  function handlePointerUp(e) {
    if(!isDrawing) return;
    isDrawing = false;

    // valide chemin s'il relie les deux points start
    if(isPathValid(drawingColor, drawingPath)) {
      drawPath(drawingColor, drawingPath);
    } else {
      clearPath(drawingColor);
    }
    renderBoard();

    drawingColor = null;
    drawingPath = [];

    if(isBoardComplete()) {
      onLevelComplete();
    }
  }

  function onLevelComplete() {
    message.textContent = "Niveau terminé ! 🎉";
    if(mode === "campaign") {
      if(level < maxLevel) {
        setTimeout(() => {
          level++;
          startLevel(level);
          message.textContent = "";
        }, 1500);
      } else {
        message.textContent = "Félicitations, tu as terminé la campagne ! 👏";
      }
    } else if(mode === "practice") {
      setTimeout(() => {
        startLevel(level); // regen level practice
        message.textContent = "";
      }, 1500);
    }
  }

  // Lance un niveau en fonction du mode
  function startLevel(lvl) {
    levelIndicator.textContent = (mode === "campaign") ? `Niveau ${lvl}` : "Mode Practice";
    if(mode === "campaign") {
      generateCampaignLevel(lvl);
    } else {
      generatePracticeLevel();
    }
    paths = {};
    drawingColor = null;
    drawingPath = [];
    message.textContent = "";
    renderBoard();
  }

  // Gestion boutons
  document.getElementById("btn-campaign").onclick = () => {
    mode = "campaign";
    level = 1;
    modeSelect.style.display = "none";
    gameContainer.style.display = "block";
    startLevel(level);
  };
  document.getElementById("btn-practice").onclick = () => {
    mode = "practice";
    level = 0;
    modeSelect.style.display = "none";
    gameContainer.style.display = "block";
    startLevel(level);
  };
  btnRestart.onclick = () => {
    startLevel(level);
  };
  btnBack.onclick = () => {
    mode = null;
    modeSelect.style.display = "block";
    gameContainer.style.display = "none";
    message.textContent = "";
  };

  // Events pointer (mouse + touch)
  boardElem.addEventListener("pointerdown", handlePointerDown);
  boardElem.addEventListener("pointermove", handlePointerMove);
  boardElem.addEventListener("pointerup", handlePointerUp);
  boardElem.addEventListener("pointercancel", handlePointerUp);
  boardElem.addEventListener("pointerleave", handlePointerUp);

})();
</script>

</body>
</html>
